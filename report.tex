\documentclass[11pt,british,a4paper]{report}
%\pdfobjcompresslevel=0
%\usepackage{pythontex}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage[includeheadfoot,margin=0.8 in]{geometry}
\usepackage{siunitx,physics,cancel,upgreek,varioref,listings,booktabs,pdfpages,ifthen,polynom,todonotes}
%\usepackage{minted}
\usepackage[backend=biber]{biblatex}
\DefineBibliographyStrings{english}{%
      bibliography = {References},
}
\addbibresource{sources.bib}
\usepackage{mathtools,upgreek,bigints}
\usepackage{babel}
\usepackage{graphicx}
\graphicspath{{./}{./e/}}
\usepackage{float}
\usepackage{amsmath}
\usepackage{amssymb,epstopdf}
\usepackage[T1]{fontenc}
%\usepackage{fouriernc}
% \usepackage[T1]{fontenc}
\usepackage{mathpazo}
% \usepackage{inconsolata}
%\usepackage{eulervm}
%\usepackage{cmbright}
%\usepackage{fontspec}
%\usepackage{unicode-math}
%\setmainfont{Tex Gyre Pagella}
%\setmathfont{Tex Gyre Pagella Math}
%\setmonofont{Tex Gyre Cursor}
%\renewcommand*\ttdefault{txtt}
\usepackage[scaled]{beramono}
\usepackage{fancyhdr}
\usepackage[utf8]{inputenc}
\usepackage{textcomp}
\usepackage{lastpage}
\usepackage{microtype}
\usepackage{subcaption}
\usepackage{luacode}
\usepackage[linktoc=all, bookmarks=true, pdfauthor={Anders Johansson},pdftitle={FYS4460 Project 3}]{hyperref}
\usepackage{tikz,pgfplots,pgfplotstable}
\usepgfplotslibrary{colorbrewer}
\usepgfplotslibrary{external}
\tikzset{external/system call={lualatex \tikzexternalcheckshellescape -halt-on-error -interaction=batchmode -jobname "\image" "\texsource"}}
\tikzexternalize[prefix=tmp/, mode=list and make]
\pgfplotsset{cycle list/Dark2}
\pgfplotsset{compat=1.8}
\renewcommand{\CancelColor}{\color{red}}
\let\oldexp=\exp
\renewcommand{\exp}[1]{\mathrm{e}^{#1}}
\renewcommand{\Re}[1]{\mathfrak{Re}\ifthenelse{\equal{#1}{}}{}{\left(#1\right)}}
\renewcommand{\Im}[1]{\mathfrak{Im}\ifthenelse{\equal{#1}{}}{}{\left(#1\right)}}
\renewcommand{\i}{\mathrm{i}}
\newcommand{\tittel}[1]{\title{#1 \vspace{-7ex}}\author{}\date{}\maketitle\thispagestyle{fancy}\pagestyle{fancy}\setcounter{page}{1}}

% \newcommand{\deloppg}[2][]{\subsection*{#2) #1}\addcontentsline{toc}{subsection}{#2)}\refstepcounter{subsection}\label{#2}}
% \newcommand{\oppg}[1]{\section*{Oppgave #1}\addcontentsline{toc}{section}{Oppgave #1}\refstepcounter{section}\label{oppg#1}}

\labelformat{section}{#1}
\labelformat{subsection}{exercise~#1}
\labelformat{subsubsection}{paragraph~#1}
\labelformat{equation}{equation~(#1)}
\labelformat{figure}{figure~#1}
\labelformat{table}{table~#1}

\renewcommand{\footrulewidth}{\headrulewidth}

%\setcounter{secnumdepth}{4}
\renewcommand{\thesection}{Oppgave \arabic{section}}
\renewcommand{\thesubsection}{\alph{subsection})}
\renewcommand{\thesubsubsection}{\arabic{section}\alph{subsection}\roman{subsubsection})}
\setlength{\parindent}{0cm}
\setlength{\parskip}{1em}

\definecolor{bluekeywords}{rgb}{0.13,0.13,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.9,0,0}
\lstset{rangeprefix=!/,
    rangesuffix=/!,
    includerangemarker=false}
\renewcommand{\lstlistingname}{Kodesnutt}
\lstset{showstringspaces=false,
    basicstyle=\small\ttfamily,
    keywordstyle=\color{bluekeywords},
    commentstyle=\color{greencomments},
    numberstyle=\color{bluekeywords},
    stringstyle=\color{redstrings},
    breaklines=true,
    %texcl=true,
    language=Fortran
}
\colorlet{DarkGrey}{white!20!black}
\newcommand{\eqtag}[1]{\refstepcounter{equation}\tag{\theequation}\label{#1}}
\hypersetup{hidelinks=True}

\sisetup{detect-all}
\sisetup{exponent-product = \cdot, output-product = \cdot,per-mode=symbol}
% \sisetup{output-decimal-marker={,}}
\sisetup{round-mode = off, round-precision=3}
\sisetup{number-unit-product = \ }

\allowdisplaybreaks[4]
\fancyhf{}

\rhead{Project 3}
\rfoot{Page~\thepage{} of~\pageref{LastPage}}
\lhead{FYS4460}

%\definecolor{gronn}{rgb}{0.29, 0.33, 0.13}
\definecolor{gronn}{rgb}{0, 0.5, 0}

\newcommand{\husk}[2]{\tikz[baseline,remember picture,inner sep=0pt,outer sep=0pt]{\node[anchor=base] (#1) {\(#2\)};}}
\newcommand{\artanh}[1]{\operatorname{artanh}{\qty(#1)}}
\newcommand{\matrise}[1]{\begin{pmatrix}#1\end{pmatrix}}


\pgfplotstableset{1000 sep={\,},
                      assign column name/.style={/pgfplots/table/column name={\multicolumn{1}{c}{#1}}},
                      every head row/.style={before row=\toprule,after row=\midrule},
                      every last row/.style={after row=\bottomrule},
                      columns/n/.style={column name={\(n^*\)},column type={r}},
                      columns/N/.style={column name={\(N\)},sci},
                      columns/logN/.style={column name={\(\log(N)\)}},
                      columns/logn/.style={column name={\(\log(n^*)\)}}
                      }

\newread\infile

%start
\begin{document}
\title{FYS4460: Project 1}
\author{Anders Johansson}
%\maketitle

\begin{titlepage}
%\includegraphics[width=\textwidth]{fysisk.pdf}
\vspace*{\fill}
\begin{center}
\textsf{
    \Huge \textbf{Project 3}\\\vspace{0.5cm}
    \Large \textbf{FYS4460 - Disordered systems and percolation}\\
    \vspace{8cm}
    Anders Johansson\\
    \today\\
}
\vspace{1.5cm}
\includegraphics{uio.pdf}\\
\vspace*{\fill}
\end{center}
\end{titlepage}
\null
\pagestyle{empty}
\newpage

\pagestyle{fancy}
\setcounter{page}{1}

All files for this project are available at \url{https://github.com/anjohan/fys4460-3}.

%   __ _
%  / _` |
% | (_| |
%  \__,_|
%
\subsection{}
As my Easter procrastination was reading a Fortran book\cite{brainerd_guide_2015}, I decided to implement this project in Fortran. Since there is no \lstinline{scipy.ndimage.measurements.label} in Fortran, the most important step was to implement an algorithm for labelling clusters in a binary matrix. Many high-performance algorithms exist for this task, and implementations of several of these in Fortran can be found on the internet. I, however, came up with a low-performance algorithm myself and chose to implement it for fun.

My algorithm goes through the entire grid, and for each site checks if it is occupied and unlabelled. If both these conditions are met, a recursive algorithm grows the entire cluster connected to this site.

The main algorithm is the \lstinline{label} subroutine,
\lstinputlisting[linerange={labelsubroutinestart-labelsubroutineend}]{lib/percolation.f90}
where the recursive \lstinline{growcluster} subroutine simply checks if each neighbouring site is occupied and unlabelled,
\lstinputlisting[linerange={growclustersubroutinestart-growclustersubroutineend}]{lib/percolation.f90}
This algorithm is easily extensible to other geometries and connectivities, as the basic idea ``check all sites, check all neighbours'' is generally valid. Higher dimensions should also be unproblematic, although a generalisation of checking all neighbours would be useful to avoid tedious coding.

There is, however, one pressing issue with this algorithm: It is recursive (and not tail-recursive). As a result, it will give a stack overflow for sufficiently large simulations. For this reason, I reluctantly had to abandon my algorithm and instead write a small Fortran interface for a C implementation of the Hoshen-Kopelman algorithm found on the internet\cite{fricke_hoshen-kopelman_2004}. Unfortunately, this implementation uses a lot of global variables and is not thread safe, so I now have my own Fortran implementation.

Spanning cluster detection is done by checking if either the top and bottom rows or the left and right columns contain common elements. This is implemented by first going through one of the arrays and registering which labels are present, and then going through the other array and checking if any of the labels in this array were also present in the first,
\lstinputlisting[linerange={intersectsnippetstart-intersectsnippetend}]{lib/percolation.f90}
The algorithm assumes that there is only one spanning cluster. This should be unproblematic, as it is highly unlikely that two clusters stretch from one side of the grid to the other without touching each other and thus being the same cluster. When the label of the spanning cluster has been found, the area is straightforwardly calculated by a command like \lstinline{count(labelled_matrix == spanning_label)}.
A sample run gives
\lstinputlisting{tmp/verification.txt}

The functions \(\Pi(p,L)\) and \(P(p,L)\) are estimated by repeating a simulation multiple times. \(\Pi(p,L)\) is the number of repetitions which lead to a spanning cluster divided by the total number of repetitions, while \(P(p,L)\) is estimated by the average size of the spanning cluster (or zero if there isn't one), divided by the total size of the grid, \(L^2\). Averaging over many cycles is trivially parallelisable with OpenMP.

%  _
% | |__
% | '_ \
% | |_) |
% |_.__/
%
\subsection{}
The probability of having a spanning cluster, \(\Pi(p,L)\), and the density of the spanning cluster, \(P(p,L)\), were estimated with the Fortran machinery described in the previous exercise. \(\Pi(p,L)\) is calculated by creating many random, binary matrices, counting the numbers of matrices which have a spanning cluster and dividing by the total number of matrices created.

If there is no spanning cluster, \(P(p,L)=0\), otherwise it is equal to the number of sites belonging to the spanning cluster, divided by the total number of sites. Hence it is equal to the probability of one randomly selected site being on the spanning cluster. An estimate is found by creating and labelling many binary matrices and averaging the number of sites on the spanning cluster (or zero), and dividing by the total number of sites on the lattice.

Mathematically,
\begin{alignat}{2}
    \Pi(p,L) &= \frac{\displaystyle\sum_{\text{cycles}} \begin{cases}1, & \text{spanning cluster exists}\\ 0, & \text{no spanning cluster exists}\end{cases}}{\text{number of cycles}}
    \shortintertext{and}
    P(p,L) &= \frac{\displaystyle\sum_{\text{cycles}} \begin{cases}0,&\text{no spanning cluster exists}\\& \text{mass of spanning cluster} \end{cases}}{L^2\cdot\text{number of cycles}}.
\end{alignat}

A variety of system sizes \(L\) and numbers of samples were used for probabilities in the range from zero to one. See~\vref{fig:PI} and~\vref{fig:PL}.
\begin{figure}[H]
    \centering
    \begin{subfigure}{\textwidth}
        \centering
        \begin{tikzpicture}
            \begin{axis}[
                legend style={draw=none,at={(1.0,0.8)}},
                legend cell align=left,
                thick,
                axis lines=middle,
                xlabel style={anchor=north west},
                ylabel style={anchor=east},
                %axis y discontinuity=crunch,
                enlarge x limits=0.05,
                enlarge y limits=0.1,
                width=6in, height=3in,
                xlabel={\(p\)},
                ylabel={\(\Pi(p,L)\)}
                ]
                    \foreach \systemsize in {2,4,8,16,32,64,128} {
                        \addplot+[mark=none] table {tmp/PI_1000_\systemsize.dat};
                        \addlegendentryexpanded{\(L = \num{\systemsize} \)};
                    }
            \end{axis}
        \end{tikzpicture}
        \caption{Different system sizes. As \(L\) increases, the function shape approaches a step function, with a clearly defined critical probability \(p_\mathrm{c}\). Averaged over \(\num{1000}\) Monte Carlo samples.}%
    \end{subfigure}
    \begin{subfigure}{\textwidth}
        \centering
        \begin{tikzpicture}
            \begin{axis}[
                legend style={draw=none,at={(1.0,0.65)}},
                legend cell align=left,
                thick,
                axis lines=middle,
                xlabel style={anchor=north west},
                ylabel style={anchor=east},
                %axis y discontinuity=crunch,
                enlarge x limits=0.05,
                enlarge y limits=0.1,
                width=6in, height=3in,
                xlabel={\(p\)},
                ylabel={\(\Pi(p,L)\)}
                ]
                    \foreach \systemsize in {2,128} {
                        \foreach \numsamples in {10,100,1000}{
                            \addplot+[mark=none] table {tmp/PI_\numsamples_\systemsize.dat};
                            \addlegendentryexpanded{\(L = \systemsize\), \(\num{\numsamples}\) samples};
                        }
                    }
            \end{axis}
        \end{tikzpicture}
        \caption{Different numbers of Monte Carlo cycles for the largest and smallest system sizes simulated.}%
    \end{subfigure}
    \caption{Probability of having a spanning cluster, compared both for different system sizes and for different numbers of Monte Carlo cycles. The graphs show that large systems give good results with very few samples, while small systems require a large number of samples to give good results with little noise.}
    \label{fig:PI}
\end{figure}
\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            legend style={draw=none,at={(1.0,0.7)}},
            legend cell align=left,
            thick,
            axis lines=middle,
            xlabel style={anchor=north west},
            ylabel style={anchor=east},
            %axis y discontinuity=crunch,
            enlarge x limits=0.05,
            enlarge y limits=0.1,
            width=6in, height=3in,
            xlabel={\(p\)},
            ylabel={\(P(p,L)\)}
            ]
                \foreach \systemsize in {2,4,8,16,32,64,128} {
                    \addplot+[mark=none] table {tmp/P_1000_\systemsize.dat};
                    \addlegendentryexpanded{\(L = \num{\systemsize} \)};
                }
        \end{axis}
    \end{tikzpicture}
    \caption{Spanning cluster density as a function of the probability \(p\) for a site to permit transport, for several system sizes, with \(\num{1000}\) samples. For large systems, the density has a clear jump when it becomes probable to have a spanning cluster. Beyond this value, the density increases linearly as the size of the spanning cluster increases.}%
    \label{fig:PL}
\end{figure}

\subsection{}
The same functions as in the previous exercise were used to calculate \(P(p,L)\) for probabilities going from slightly above the critical probability, \(p_c\), to \(\SI{20}{\percent}\) above \(p_c\). A lower bound of exactly \(p_c\) makes the computer complain when attempting to calculate \(\ln(p-p_c)\).

According to the exercise description, the spanning cluster density \(P(p,L)\) should be proportional to \(\qty(p-p_c)^\beta\) for some exponent \(\beta\) for \(p>p_c\). The exponent is found by doing linear regression on a log-log scale, as
\begin{equation}
    P(p,L) = a\qty(p-p_c)^\beta \implies \log_{10}(P(p,L)) = \log_{10}(a) + \beta\log_{10}(p-p_c).
\end{equation}
\openin\infile=tmp/c_beta.dat
\read\infile to \mybeta
\closein\infile
The exponent is therefore the slope of \(\log_{10}(P(p,L))\) as a function of \(\log_{10}(p-p_c)\). \Vref{fig:cP} shows the simulation results together with the theoretical model with \(\beta=\num{\mybeta}\) found from linear regression.

Fortran does, unfortunately, not have an \lstinline{np.polyfit} function, so the linear fit was done manually by calling a least squares subroutine from LAPACK.\@ \Vref{fig:cP} shows the result.

A fairly poor fit is found for probabilities which are either close to or far away from the critical probability. The error for probabilities close to the critical probability is due to finite size effects; the theoretical model is exactly zero, while the finite size of the lattice causes the spanning cluster density to become non-zero even when \(p\) is slightly smaller than \(p_c\). On the opposite side of the spectrum, the deviation is also large when \(p\gg p_c\) due to the limited range of validity for the theoretical model.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            legend style={draw=none,at={(1.0,0.7)}},
            legend cell align=left,
            thick,
            %axis lines=middle,
            xlabel style={anchor=west},
            ylabel style={anchor=south east},
            %axis y discontinuity=crunch,
            enlarge x limits=0.05,
            enlarge y limits=0.1,
            width=6in, height=3in,
            xlabel={\(p\)},
            ylabel={\(P(p,L)\)},
            xtick distance=0.002,
            x tick label style={
                /pgf/number format/fixed,
                /pgf/number format/fixed zerofill,
                /pgf/number format/precision=3,
            }
            ]
            \addplot+[mark=none] table[x index=0, ,y index=1] {tmp/c_P.dat};
            \addlegendentryexpanded{Simulation results};
            \addplot+[mark=none] table[x index=0, ,y index=2] {tmp/c_P.dat};
            \addlegendentryexpanded{\(c\qty(p-p_c)^{\num{\mybeta}}\)};
        \end{axis}
    \end{tikzpicture}
    \caption{Spanning cluster density as a function of the probability \(p\) with \(L=\num{1024}\) and \(\num{50}\) cycles for probabilities in the region just above the critical probability. The result is compared with \(c\qty(p-p_c)^\beta\), where \(\beta\) is found by doing a linear fit on a logarithmic scale. }%
    \label{fig:cP}
\end{figure}


%      _
%   __| |
%  / _` |
% | (_| |
%  \__,_|
%
\subsection{}
The cumulative distribution and the derivative, which approximates the probability distribution, were straightforwardly calculated using
\lstinputlisting[language=Python,rangeprefix=\#\ /,rangesuffix=/\ \#, linerange={Pstart-Pend}]{src/d.py}
and the results are shown in~\vref{fig:d}.
\openin\infile=tmp/d_a.dat
\read\infile to\myslope
\closein\infile
\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \begin{tikzpicture}
            \begin{axis}[
                legend style={draw=none,at={(1.0,0.7)}},
                legend cell align=left,
                thick,
                axis lines=middle,
                %xlabel style={anchor=north},
                %ylabel style={anchor=south east},
                %axis y discontinuity=crunch,
                xmin=0,
                enlarge x limits=0.05,
                enlarge y limits=0.1,
                width=3.4in, height=3in,
                xlabel={\(z\)},
                ylabel={\(P(z)\)},
                ]
                \addplot+[mark=none] table {tmp/d_P.dat};
            \end{axis}
        \end{tikzpicture}
        \caption{Cumulative distribution.}%
    \end{subfigure}\quad
    \begin{subfigure}[b]{0.45\textwidth}
        \begin{tikzpicture}
            \begin{axis}[
                legend style={draw=none,at={(1.1,0.8)},anchor=east},
                legend cell align=left,
                thick,
                axis lines=middle,
                %xlabel style={anchor=north},
                ylabel style={anchor=east},
                %axis y discontinuity=crunch,
                xmin=0,
                ymax=10,
                restrict x to domain=0:200,
                restrict y to domain=0:200,
                enlarge x limits=0.05,
                enlarge y limits=0.1,
                width=3.4in, height=3in,
                xlabel={\(z\)},
                ylabel={\(f(z)\)},
                ]
                \addplot+[mark=none] table {tmp/d_f.dat};
                \addlegendentryexpanded{Simulation result.};
                \addplot+[mark=none] table {tmp/d_fapprox.dat};
                \addlegendentryexpanded{Approximation \(z^{\num{\myslope}}\)};
            \end{axis}
        \end{tikzpicture}
        \caption{Probability distribution.}%
    \end{subfigure}
    \caption{The result of raising a uniform distribution between \(0\) and \(1\) to the power \(-2\). While the cumulative distribution looks good, it is clear that some sort of averaging over bins is necessary in order to get a reasonable probability distribution.}%
    \label{fig:d}
\end{figure}



%   ___
%  / _ \
% |  __/
%  \___|
%
\subsection{}
The listed algorithm can be used to calculate the cluster number density \(n(s,p)\) with logarithmically binned sizes. \(n(s,p)\) is defined as the probability of a randomly selected site being a specific site on a cluster with size \(s\). It can therefore be calculated as
\begin{equation}
    n(s,p) = \frac{\displaystyle\sum_{\text{cycles}}\text{number of clusters with size } s}{\text{number of cycles}}.
\end{equation}
Due to the skewed distribution of cluster sizes, with many being small and few large clusters (except for the spanning cluster, which is ignored), this method would give similarly poor results as in~\vref{fig:d}. Consequently, the sizes should be binned logarithmically and the results averaged, i.e.
\begin{equation}
    n\left(\left[s,s+\Delta s\right),p\right) = \displaystyle\sum_{\text{cycles}}\frac{\text{number of clusters with size between } s \text{ and } s+\Delta s}{L^2 \cdot \Delta s \cdot \text{number of cycles}}.
\end{equation}
\lstinputlisting[language=Fortran,linerange={cndstart-cndend}]{lib/percolation.f90}


%   __
%  / _|
% | |_
% |  _|
% |_|
%
\subsection{}
The cluster number density algorithm from the previous exercise was used. \Vref{fig:f} shows the result for various values of \(p\) for a fixed system size.
\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            xmode=log, ymode=log,
            ymin=0.000000000001,
            legend style={draw=none,at={(0.02,0.02)},anchor=south west},
            legend cell align=left,
            legend columns=2,
            thick,
            %axis lines=middle,
            xlabel style={anchor=west},
            ylabel style={anchor=south east},
            %axis y discontinuity=crunch,
            enlarge x limits=0.05,
            enlarge y limits=0.1,
            width=6in, height=3in,
            xlabel={\(s\)},
            ylabel={\(n(s,p)\)},
            ]
            \begin{luacode*}
                local i = 0
                for line in io.lines("tmp/f_p.dat") do
                    i = i + 1
                    print(line)
                    txt = "\\addplot+[mark=none] table {tmp/f_p_" .. tostring(i) .. ".dat}; \\addlegendentryexpanded{\\(p = \\num{" .. line .. "}\\)};"
                    tex.sprint(txt)
                end
            \end{luacode*}
        \end{axis}
    \end{tikzpicture}
    \caption{Cluster number density as a function of size for a few different probabilities, with \(L=\num{1024}\) and \(\num{100}\) Monte Carlo cycles. As \(p\) approaches \(p_c\) from below, a larger and larger portion of the graph is approximately linear. Since both axes are logarithmic, this implies a power-law behaviour, \(n(s,p)\propto s^{-\tau}\).}%
    \label{fig:f}
\end{figure}


%   __ _
%  / _` |
% | (_| |
%  \__, |
%  |___/
\openin\infile=tmp/g_9_tau.dat
\read\infile to \mytau
\closein\infile
\subsection{}
As seen in~\vref{fig:f}, the cluster number density has a large linear part when \(p\to p_c\). Both axes in this figure are logarithmic, so the linearity implies a power-law behaviour for \(n(s,p_c)\), i.e. \(n(s,p_c)\propto s^{-\tau}\). \Vref{fig:g} shows \(n(s,p_c)\) with \(L^i\), \(i\in\qty{4,\dots,9}\), as well as the result of a linear fit for the largest system size. The linear part is found by staring at the graph, and the resulting exponent is \(\tau=\num{\mytau}\).
\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            xmode=log, ymode=log,
            ymin=0.00000000001,
            legend style={draw=none,at={(0.02,0.02)},anchor=south west},
            legend cell align=left,
            legend columns=3,
            thick,
            %axis lines=middle,
            xlabel style={anchor=west},
            ylabel style={anchor=south east},
            %axis y discontinuity=crunch,
            enlarge x limits=0.05,
            enlarge y limits=0.1,
            width=6in, height=3in,
            xlabel={\(s\)},
            ylabel={\(n(s,p_c)\)},
            ]
            \addplot+[mark=none,dashed] table {tmp/g_9_approx.dat};
            \addlegendentryexpanded {\(s^{-\num{\mytau}}\)};
            \foreach \exponent in {9,8,...,4}{
                \addplot+[mark=none] table {tmp/g_\exponent.dat};
                \addlegendentryexpanded {\(L = 2^\exponent\)};
            }
        \end{axis}
    \end{tikzpicture}
    \caption{Cluster number density as a function of size with \(p=p_c\) and \(\num{1000}\) Monte Carlo cycles. The power-law model fits well over a large range of sizes.}%
    \label{fig:g}
\end{figure}

%  _
% | |__
% | '_ \
% | | | |
% |_| |_|
\openin\infile=tmp/h_sigma.dat
\read\infile to \mysigma
\closein\infile
\subsection{}
Comparing~\vref{fig:f} with~\vref{fig:g} shows that when \(p\approx p_c\), \(n(s,p)\) has a linear portion similar to that of \(n(s,p_c)\), but it falls off from the linear trend when \(s\) becomes large. This point of departure can be defined as a characteristic size \(s_\xi\). It can be numerically estimated as the point where \(n(s,p)\leq \tfrac{1}{2}n(s,p_c)\).

The characteristic size \(s_\xi\) can be assumed\cite{malthe-sorenssen_percolation_2015} to be proportional to \(\abs{p-p_c}^{-1/\sigma}\), where \(\sigma\) once again is found by doing linear regression on a logarithmic scale.~\Vref{fig:h} shows the cluster number density as a function of size for probabilities approaching \(p_c\), with \(s_\xi\) marks based on the numerical estimate described above. The resulting \(s_\xi(p)\) is shown in~\vref{fig:h2}, and the theoretical model \(\abs{p-p_c}^{-1/\num{\mysigma}}\) gives a good approximation of the simulation results.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            xmode=log, ymode=log,
            ymin=0.000000000001,
            legend style={draw=none,at={(0.02,0.02)},anchor=south west},
            legend cell align=left,
            legend columns=2,
            thick,
            %axis lines=middle,
            xlabel style={anchor=west},
            ylabel style={anchor=south east},
            %axis y discontinuity=crunch,
            enlarge x limits=0.05,
            enlarge y limits=0.1,
            width=6in, height=3in,
            xlabel={\(s\)},
            ylabel={\(n(s,p)\)},
            ]
            \addplot+[only marks] table {tmp/h_s_xi.dat};
            \addlegendentryexpanded{\(s_\xi\)};
            \begin{luacode*}
                local i = 0
                for line in io.lines("tmp/h_p.dat") do
                    i = i + 1
                    print(line)
                    txt = "\\addplot+[mark=none] table {tmp/h_"
                          .. tostring(i) .. ".dat};"
                          .. "\\addlegendentryexpanded{\\(p = \\num{"
                          .. line .. "}\\)};"
                    tex.sprint(txt)
                end
            \end{luacode*}
        \end{axis}
    \end{tikzpicture}
    \caption{Cluster number density as a function of size for probabilities just above \(p_c\) with \(L=512\) and \(\num{500}\) Monte Carlo cycles. The dots mark the numerical estimates of \(s_\xi\).}%
    \label{fig:h}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            legend style={draw=none,at={(1.0,0.7)}},
            legend cell align=left,
            thick,
            xmin=0.4, xmax=0.7,
            %axis lines=middle,
            %xlabel style={anchor=north},
            %ylabel style={anchor=south east},
            %axis y discontinuity=crunch,
            enlarge x limits=0.05,
            enlarge y limits=0.1,
            width=6in, height=3in,
            xlabel={\(p\)},
            ylabel={\(s_\xi\)},
            xtick distance=0.05,
            ]
            \addplot+[only marks] table[x index=0, ,y index=1] {tmp/h_s_xi2.dat};
            \addlegendentryexpanded{Simulation results};
            \addplot+[mark=none] table[x index=0, ,y index=2] {tmp/h_s_xi2.dat};
            \addlegendentryexpanded{\(\abs{p-p_c}^{-1/\num{\mysigma}}\)};
        \end{axis}
    \end{tikzpicture}
    \caption{Characteristic cluster size \(s_\xi\) as a function of probability. As the probability approaches the critical probability, \(s_\xi\) diverges. The parameters of the power law model are found from linear regression on a logarithmic scale, and the resulting approximation looks good.}%
    \label{fig:h2}
\end{figure}

%  _
% (_)
% | |
% | |
% |_|
%
\openin\infile=tmp/i_D.dat
\read\infile to \myD
\closein\infile
\subsection{}
The mass of the percolating/spanning cluster \(M\) should be proportional to some power of the system size \(L\). Intuitively, the exponent should be equal to the dimension of the system (\(2\) in this project), but the non-trivial geometry of the spanning cluster causes the exponent to deviate from this expectation. This is confirmed by the numerically determined \(D=\num{\myD}<2\). \Vref{fig:i} shows the quality of the approximation.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            xmode=log, ymode=log,
            log basis x=2,
            legend style={draw=none,at={(0.02,0.98)},anchor=north west},
            legend cell align=left,
            %legend columns=3,
            thick,
            %axis lines=middle,
            %xlabel style={anchor=west},
            %ylabel style={anchor=south east},
            %axis y discontinuity=crunch,
            enlarge x limits=0.05,
            enlarge y limits=0.1,
            width=6in, height=3in,
            xlabel={\(L\)},
            ylabel={\(M\)},
            ]
            \addplot+[only marks] table[x index=0, y index=1] {tmp/i.dat};
            \addlegendentryexpanded {Simulation results};
            \addplot+[mark=none] table[x index=0, y index=2] {tmp/i.dat};
            \addlegendentryexpanded {Approximation \(L^{\num{\myD}}\)};
        \end{axis}
    \end{tikzpicture}
    \caption{Mass of the percolating cluster as a function of system size, with \(p=p_c\) and \(200\) Monte Carlo cycles. The power-law model fits well, and \(D=\num{\myD}<2\) shows the non-trivial geometry of the percolating cluster.}%
    \label{fig:i}
\end{figure}

\subsection{}
Nope.
\subsection{}
Nope.

%  _
% | |
% | |
% | |
% |_|
%
\subsection{}
In this problem we are interested in calculating the inverse of \(\Pi(p,L)\), i.e.\ for a given number \(x\) determining \(p_{\Pi=x}\) such that \(\Pi(p_{\Pi=x},L) = x\). I have chosen to implement this with the bisection method, as it is very simple but also quickly converging --- the error is halved with every calculation of \(\Pi\). \Vref{fig:l} shows the result.
\lstinputlisting[linerange={invPIstart-invPIend}]{lib/percolation.f90}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            % xmode=log, ymode=log,
            % log basis x=2,
            legend style={draw=none,at={(0.98,0.02)},anchor=south east},
            legend cell align=left,
            %legend columns=3,
            thick,
            %axis lines=middle,
            %xlabel style={anchor=west},
            %ylabel style={anchor=south east},
            %axis y discontinuity=crunch,
            enlarge x limits=0.05,
            enlarge y limits=0.1,
            width=6in, height=3in,
            xlabel={\(L\)},
            ylabel={\(p_{\Pi=x} = \Pi^{-1}(x)\)},
            ]
            \addplot+[only marks] table {tmp/l_1.dat};
            \addlegendentryexpanded {\(x=\num{0.3}\)};
            \addplot+[only marks] table {tmp/l_2.dat};
            \addlegendentryexpanded {\(x=\num{0.8}\)};
        \end{axis}
    \end{tikzpicture}
    \caption{Inverse of the percolation probability \(x = \Pi(p,L)\) as a function of \(L\) for two different values of \(x\). As \(L\) increases, \(p_{\Pi=x}\) approaches the same value for both values of \(x\). This value must be \(p_c\), since~\vref{fig:PI} shows that \(\Pi(p,L)\) approaches a step function around \(p_c\) as \(L\to\infty\). \(\Pi^{-1}(p,L)\) should therefore be almost constant, with value \(p_c\), for large values of \(L\).}%
    \label{fig:l}
\end{figure}


%  _ __ ___
% | '_ ` _ \
% | | | | | |
% |_| |_| |_|
%
\openin\infile=tmp/m_nu.dat
\read\infile to \mynu
\closein\infile
\subsection{}
\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \begin{tikzpicture}
            \begin{axis}[
                thick,
                axis lines=middle,
                %xlabel style={anchor=north},
                %ylabel style={anchor=south east},
                %axis y discontinuity=crunch,
                xmin=0, samples=100,
                enlarge x limits=0.05,
                enlarge y limits=0.1,
                width=3.4in, height=3in,
                xlabel={\(p\)},
                ylabel={\(\Pi(p,L\gg 1)\)},
                ]
                \addplot+[mark=none,domain=0:1] {1/(1+exp(-2*50*(x-0.59275)))};
            \end{axis}
        \end{tikzpicture}
        \caption{Percolation probability.}%
    \end{subfigure}\quad
    \begin{subfigure}[b]{0.45\textwidth}
        \begin{tikzpicture}
            \begin{axis}[
                legend style={draw=none,at={(1.1,0.8)},anchor=east},
                legend cell align=left,
                thick, samples=100,
                axis lines=middle,
                %xlabel style={anchor=north},
                %axis y discontinuity=crunch,
                enlarge x limits=0.05,
                enlarge y limits=0.1,
                width=3.4in, height=3in,
                xlabel={\(x\)},
                ylabel={\(\Pi^{-1}(x,L\gg 1)\)},
                ]
                \addplot+[mark=none,domain=0:1] ({1/(1+exp(-2*50*(x-0.59275)))},{x});
            \end{axis}
        \end{tikzpicture}
        \caption{Inverse percolation probability.}%
    \end{subfigure}
    \caption{Approximate plot of the percolation probability and its inverse when \(L\) is large. In this limit, the percolation probability is nearly a step function centred at the critical probability \(p_c\), and the inverse is consequently approximately constant, with value \(p_c\).}%
    \label{fig:PIinv}
\end{figure}
\Vref*{fig:l} shows that \(\Pi^{-1}(x)\) approaches some constant value as \(L\to\infty\). On the other hand,~\vref{fig:PI} shows that \(\Pi(p,L)\to \Theta(x-p_c)\) in the same limit, and so the constant value of \(\Pi^{-1}(x)\) must be \(p_c\). This is illustrated in~\vref{fig:PIinv}.

It is difficult to exactly determine the nature of the approach to \(p_c\) from~\vref{fig:l}, but everything else in the world of percolation is a power law, so it seems reasonable to hope that this should be the case for \(\Pi^{-1}(x) - p_c\) as well, i.e.
\begin{equation}
    \Pi^{-1}(x,L) = p_c + C(x)L^{-1/\nu}
\end{equation}
for some \(\nu\).
This equation can be used to determine \(\nu\), as
\[
    \Pi^{-1}(x_1,L) - \Pi^{-1}(x_2,L) = \qty(C(x_1) - C(x_2))L^{-1/\nu},
\]
so that \(-1/\nu\) will be the slope when plotting \(\Pi^{-1}(x_1,L) - \Pi^{-1}(x_2,L)\) as a function of \(L\) on a logarithmic scale. Linear fitting gives \(\nu=\num{\mynu}\), which is close to the exact value \(\nu=4/3\). \Vref{fig:m} shows the results.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            xmode=log, ymode=log,
            log basis x=2,
            legend style={draw=none,at={(0.98,0.98)},anchor=north east},
            legend cell align=left,
            %legend columns=3,
            thick,
            %axis lines=middle,
            %xlabel style={anchor=west},
            %ylabel style={anchor=south east},
            %axis y discontinuity=crunch,
            enlarge x limits=0.05,
            enlarge y limits=0.1,
            width=6in, height=3in,
            xlabel={\(L\)},
            ylabel={\(\Pi^{-1}(\num{0.8},L) - \Pi^{-1}(\num{0.3},L)\)},
            ]
            \addplot+[only marks] table[x index=0, y index=1] {tmp/m.dat};
            \addlegendentryexpanded {Simulation results};
            \addplot+[mark=none] table[x index=0, y index=2] {tmp/m.dat};
            \addlegendentryexpanded {Approximation \(L^{-1/\num{\mynu}}\)};
        \end{axis}
    \end{tikzpicture}
    \caption{Difference in inverse percolation probability as a function of \(L\). The approximately linear trend on a logarithmic scale validates the guess of yet another power-law behaviour.}%
    \label{fig:m}
\end{figure}


%  _ __
% | '_ \
% | | | |
% |_| |_|
%
\subsection{}
\Vref*{fig:m} confirms the power-law behaviour of the approach of \(\Pi^{-1}(x,L)\) to \(p_c\) as a function of \(L\), i.e.
\[
    \Pi^{-1}(x,L) = p_c + C(x)L^{-1/\nu},
\]
where \(\nu\) is known to be exactly \(4/3\). \(\Pi^{-1}\) should therefore be a linear function of \(L^{-1/\nu}\), with \(p_c\) as value at \(L^{-1/\nu}=0\), i.e. \(L=\infty\). The critical probability can therefore be estimated by calculating \(\Pi^{-1}\) as a function of \(L^{-1/\nu}\), doing linear regression and extracting the constant term. This gives~\vref{fig:n1}, and the different values of \(x\) give similar and quite accurate estimates for \(p_c\).
\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            legend style={draw=none,at={(0.06,0.02)},anchor=south west},
            legend cell align=left,
            legend columns=1,
            thick,
            axis lines=middle,
            xlabel style={anchor=north},
            %ylabel style={anchor=south east},
            axis y discontinuity=crunch,
            enlarge x limits=0.05,
            enlarge y limits=0.14,
            width=6in, height=3in,
            xlabel={\(L^{-1/\nu}\)},
            ylabel={\(\Pi^{-1}(x,L)\)},
            xtick distance=0.02,
            x tick label style={
                /pgf/number format/.cd,
                    fixed,
                    fixed zerofill,
                    precision=2,
                /tikz/.cd
            }
            ]
            \begin{luacode*}
                local i = 0
                for line in io.lines("tmp/n_x.dat") do
                    i = i + 1
                    print(line)
                    myfile = io.open("tmp/n_pc_" .. tostring(i) .. ".dat", "r")
                    local pc = myfile.read(myfile)
                    txt = "\\addplot+[only marks] table {tmp/n_"
                          .. tostring(i) .. ".dat};"
                          .. "\\addlegendentryexpanded{\\(x = \\num{"
                          .. line .. "}, p_c = \\num{" .. pc .. "}\\)};"
                    tex.sprint(txt)
                end
                local i = 0
                for line in io.lines("tmp/n_x.dat") do
                    i = i + 1
                    txt = "\\addplot+[mark=none,gray] table {tmp/n_"
                          .. tostring(i) .. "_approx.dat};"
                    tex.sprint(txt)
                end
            \end{luacode*}
        \end{axis}
    \end{tikzpicture}
    \caption{Inverse percolation probability \(\Pi^{-1}(x,L)\) as a function of \(L^{-1/\nu}\) for a few different values of \(x\), together with linear fits. The intersection between the linear fit and the \(y\)-axis gives an estimate for the critical probability \(p_c\).}%
    \label{fig:n1}
\end{figure}
The function \(C(x)\) in
\begin{equation}
    \Pi^{-1}(x,L) = p_c + C(x)L^{-1/\nu}
\end{equation}
is what the lecture notes call \(\Phi^{-1}(x)\). Consequently, with \(p=\Pi^{-1}(x,L)\),
\begin{equation}
    p - p_c = \Phi^{-1}(x) L^{-1/\nu} \implies \Phi^{-1}(x) = \qty(p-p_c)L^{1/\nu}.
\end{equation}
By definition, \(x=\Pi(p,L)\), and hence applying \(\Phi\) on both sides gives
\begin{equation}
    \Pi(p,L) = \Phi\qty(\qty(p-p_c)L^{1/\nu}).
\end{equation}
The shape of the function \(\Phi(u)\) can therefore be determined by plotting \(\Pi(p,L)\) as a function of \(\qty(p-p_c)L^{1/\nu}\). I have chosen to vary \(p\) for a few different values of \(L\).

\Vref*{fig:ncollapse} displays the data collapse, and the results show that the graphs of \(\Pi(p,L)\) overlap when \(\qty(p-p_c)L^{1/\nu}\) is used as the \(x\)-axis. The shape of the function \(\Phi(u)\) looks to be what a physicist would call ``reverse Fermi-Dirac with \(\mu=0\)'', i.e.\ a logistic function.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            % xmode=log, ymode=log,
            % ymin=0.000000000001,
            legend style={draw=none,at={(0.02,0.98)},anchor=north west},
            legend cell align=left,
            legend columns=2,
            thick,
            xmin=-5,
            xmax=5,
            axis lines=middle,
            %xlabel style={anchor=west},
            %ylabel style={anchor=south east},
            %axis y discontinuity=crunch,
            enlarge x limits=0.05,
            enlarge y limits=0.1,
            width=6in, height=3in,
            xlabel={\(\qty(p-p_c)L^{1/\nu}\)},
            ylabel={\(\Pi\)},
            ]
            \begin{luacode*}
                local i = 0
                for line in io.lines("tmp/n_Lpows.dat") do
                    i = i + 1
                    print(line)
                    txt = "\\addplot+[mark=none] table {tmp/n_collapse_"
                          .. tostring(i) .. ".dat};"
                          .. "\\addlegendentryexpanded{\\(L = 2^{\\num{"
                          .. line .. "}}\\)};"
                    tex.sprint(txt)
                end
            \end{luacode*}
        \end{axis}
    \end{tikzpicture}
    \caption{Percolation probability as a function of \(\qty(p-p_c)L^{1/\nu}\) for \(p\in\qty[0,1]\) and a few different values of \(L\). According to the finite size scaling guesses, the graphs should overlap, and the shape of the function should be that of \(\Phi(u)\). The graphs do indeed overlap quite well, and the shape of \(\Phi(u)\) looks to be approximately logistic.}%
    \label{fig:ncollapse}
\end{figure}

\subsection{}
Nope.

%  _ __
% | '_ \
% | |_) |
% | .__/
% |_|
\subsection{}
To find the singly connected bonds, i.e.\ the sites visited by both a right-turning and a left-turning walker, I have used the \lstinline{walk} function developed by Svenn-Arne Dragly, together with the following functions:
\lstinputlisting[language=Python]{lib/singlyconnected.py}
The \lstinline{walk} function implements the straightforward algorithm of left- and right-turning walkers. The right-turning walker always chooses to turn right relative to the current direction if possible, otherwise it tries to walk forward, to the left or back where it came from. Vice-versa for the left-turning walker. Once both walkers have reached the opposite side of where they came from, the sites visited by both walkers are the singly-connected bonds, i.e.\ the bonds whose removal would remove the percolating cluster.

%   __ _
%  / _` |
% | (_| |
%  \__, |
%     |_|
\openin\infile=tmp/qD.dat
\read\infile to \myD
\closein\infile
\subsection{}
As with the mass of the spanning cluster, the mass of the singly connected bonds should increase as some power of the system size \(L\) when \(p=p_c\). The exponent is once again found by doing linear regression on a logarithmic scale, and~\vref{fig:q} shows the result together with the approximate power-law \(L^{\num{\myD}}\).
\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            xmode=log, ymode=log,
            log basis x=2,
            legend style={draw=none,at={(0.02,0.98)},anchor=north west},
            legend cell align=left,
            %legend columns=3,
            thick,
            %axis lines=middle,
            %xlabel style={anchor=west},
            %ylabel style={anchor=south east},
            %axis y discontinuity=crunch,
            enlarge x limits=0.05,
            enlarge y limits=0.1,
            width=6in, height=3in,
            xlabel={\(L\)},
            ylabel={\(M_{\text{SC}}(p_c,L)\)},
            ]
            \addplot+[only marks] table[x index=0, y index=1] {tmp/q.dat};
            \addlegendentryexpanded {Simulation results};
            \addplot+[mark=none] table[x index=0, y index=2] {tmp/q.dat};
            \addlegendentryexpanded {Approximation \(L^{\num{\myD}}\)};
        \end{axis}
    \end{tikzpicture}
    \caption{Mass of the singly connected bonds as a function of system size \(L\) with \(p=p_c\). These quantities should be related by a power-law, which is confirmed by the linearity on a logarithmic scale.}%
    \label{fig:q}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            %xmode=log,
            %ymode=log,
            %xmax=0.001,
            legend style={draw=none,at={(0.02,0.98)},anchor=north west},
            legend cell align=left,
            %legend columns=3,
            thick,
            %axis lines=middle,
            %xlabel style={anchor=west},
            %ylabel style={anchor=south east},
            %axis y discontinuity=crunch,
            enlarge x limits=0.05,
            enlarge y limits=0.1,
            width=6in, height=3in,
            xlabel={\(p-p_c\)},
            ylabel={\(P_{\text{SC}}(p,L)\)},
            ]
            \addplot+[mark=none] table[x expr=\thisrowno{0}, y expr=\thisrowno{1}] {tmp/q2.dat};
        \end{axis}
    \end{tikzpicture}
    \caption{Mass of the singly connected bonds as a function of system \(p-p_c\) with \(L=512\).}%
    \label{fig:q2}
\end{figure}









\nocite{*}
\printbibliography{}
\addcontentsline{toc}{chapter}{\bibname}
\end{document}
