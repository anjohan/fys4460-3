\documentclass[11pt,british,a4paper]{report}
%\pdfobjcompresslevel=0
%\usepackage{pythontex}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage[includeheadfoot,margin=0.8 in]{geometry}
\usepackage{siunitx,physics,cancel,upgreek,varioref,listings,booktabs,pdfpages,ifthen,polynom,todonotes}
%\usepackage{minted}
\usepackage[backend=biber]{biblatex}
\DefineBibliographyStrings{english}{%
      bibliography = {References},
}
\addbibresource{sources.bib}
\usepackage{mathtools,upgreek,bigints}
\usepackage{babel}
\usepackage{graphicx}
\graphicspath{{./}{./e/}}
\usepackage{float}
\usepackage{amsmath}
\usepackage{amssymb,epstopdf}
\usepackage[T1]{fontenc}
%\usepackage{fouriernc}
% \usepackage[T1]{fontenc}
\usepackage{mathpazo}
% \usepackage{inconsolata}
%\usepackage{eulervm}
%\usepackage{cmbright}
%\usepackage{fontspec}
%\usepackage{unicode-math}
%\setmainfont{Tex Gyre Pagella}
%\setmathfont{Tex Gyre Pagella Math}
%\setmonofont{Tex Gyre Cursor}
%\renewcommand*\ttdefault{txtt}
\usepackage[scaled]{beramono}
\usepackage{fancyhdr}
\usepackage[utf8]{inputenc}
\usepackage{textcomp}
\usepackage{lastpage}
\usepackage{microtype}
\usepackage{subcaption}
\usepackage{luacode}
\usepackage[linktoc=all, bookmarks=true, pdfauthor={Anders Johansson},pdftitle={FYS4460 Project 3}]{hyperref}
\usepackage{tikz,pgfplots,pgfplotstable}
\usepgfplotslibrary{colorbrewer}
\usepgfplotslibrary{external}
\tikzset{external/system call={lualatex \tikzexternalcheckshellescape -halt-on-error -interaction=batchmode -jobname "\image" "\texsource"}}
\tikzexternalize[prefix=tmp/, mode=list and make]
\pgfplotsset{cycle list/Dark2}
\pgfplotsset{compat=1.8}
\renewcommand{\CancelColor}{\color{red}}
\let\oldexp=\exp
\renewcommand{\exp}[1]{\mathrm{e}^{#1}}
\renewcommand{\Re}[1]{\mathfrak{Re}\ifthenelse{\equal{#1}{}}{}{\left(#1\right)}}
\renewcommand{\Im}[1]{\mathfrak{Im}\ifthenelse{\equal{#1}{}}{}{\left(#1\right)}}
\renewcommand{\i}{\mathrm{i}}
\newcommand{\tittel}[1]{\title{#1 \vspace{-7ex}}\author{}\date{}\maketitle\thispagestyle{fancy}\pagestyle{fancy}\setcounter{page}{1}}

% \newcommand{\deloppg}[2][]{\subsection*{#2) #1}\addcontentsline{toc}{subsection}{#2)}\refstepcounter{subsection}\label{#2}}
% \newcommand{\oppg}[1]{\section*{Oppgave #1}\addcontentsline{toc}{section}{Oppgave #1}\refstepcounter{section}\label{oppg#1}}

\labelformat{section}{#1}
\labelformat{subsection}{exercise~#1}
\labelformat{subsubsection}{paragraph~#1}
\labelformat{equation}{equation~(#1)}
\labelformat{figure}{figure~#1}
\labelformat{table}{table~#1}

\renewcommand{\footrulewidth}{\headrulewidth}

%\setcounter{secnumdepth}{4}
\renewcommand{\thesection}{Oppgave \arabic{section}}
\renewcommand{\thesubsection}{\alph{subsection})}
\renewcommand{\thesubsubsection}{\arabic{section}\alph{subsection}\roman{subsubsection})}
\setlength{\parindent}{0cm}
\setlength{\parskip}{1em}

\definecolor{bluekeywords}{rgb}{0.13,0.13,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.9,0,0}
\lstset{rangeprefix=!/,
    rangesuffix=/!,
    includerangemarker=false}
\renewcommand{\lstlistingname}{Kodesnutt}
\lstset{showstringspaces=false,
    basicstyle=\small\ttfamily,
    keywordstyle=\color{bluekeywords},
    commentstyle=\color{greencomments},
    numberstyle=\color{bluekeywords},
    stringstyle=\color{redstrings},
    breaklines=true,
    %texcl=true,
    language=Fortran
}
\colorlet{DarkGrey}{white!20!black}
\newcommand{\eqtag}[1]{\refstepcounter{equation}\tag{\theequation}\label{#1}}
\hypersetup{hidelinks=True}

\sisetup{detect-all}
\sisetup{exponent-product = \cdot, output-product = \cdot,per-mode=symbol}
% \sisetup{output-decimal-marker={,}}
\sisetup{round-mode = off, round-precision=3}
\sisetup{number-unit-product = \ }

\allowdisplaybreaks[4]
\fancyhf{}

\rhead{Project 3}
\rfoot{Page~\thepage{} of~\pageref{LastPage}}
\lhead{FYS4460}

%\definecolor{gronn}{rgb}{0.29, 0.33, 0.13}
\definecolor{gronn}{rgb}{0, 0.5, 0}

\newcommand{\husk}[2]{\tikz[baseline,remember picture,inner sep=0pt,outer sep=0pt]{\node[anchor=base] (#1) {\(#2\)};}}
\newcommand{\artanh}[1]{\operatorname{artanh}{\qty(#1)}}
\newcommand{\matrise}[1]{\begin{pmatrix}#1\end{pmatrix}}


\pgfplotstableset{1000 sep={\,},
                      assign column name/.style={/pgfplots/table/column name={\multicolumn{1}{c}{#1}}},
                      every head row/.style={before row=\toprule,after row=\midrule},
                      every last row/.style={after row=\bottomrule},
                      columns/n/.style={column name={\(n^*\)},column type={r}},
                      columns/N/.style={column name={\(N\)},sci},
                      columns/logN/.style={column name={\(\log(N)\)}},
                      columns/logn/.style={column name={\(\log(n^*)\)}}
                      }

\newread\infile

%start
\begin{document}
\title{FYS4460: Project 1}
\author{Anders Johansson}
%\maketitle

\begin{titlepage}
%\includegraphics[width=\textwidth]{fysisk.pdf}
\vspace*{\fill}
\begin{center}
\textsf{
    \Huge \textbf{Project 3}\\\vspace{0.5cm}
    \Large \textbf{FYS4460 - Disordered systems and percolation}\\
    \vspace{8cm}
    Anders Johansson\\
    \today\\
}
\vspace{1.5cm}
\includegraphics{uio.pdf}\\
\vspace*{\fill}
\end{center}
\end{titlepage}
\null
\pagestyle{empty}
\newpage

\pagestyle{fancy}
\setcounter{page}{1}



%   __ _
%  / _` |
% | (_| |
%  \__,_|
%
\subsection{}
As my Easter procrastination was reading a Fortran book\cite{brainerd_guide_2015}, I decided to implement this project in Fortran. Since there is no \lstinline{scipy.ndimage.measurements.label} in Fortran, the most important step was to implement an algorithm for labelling clusters in a binary matrix. Many high-perfomance algorithms exist for this task, and implementations of several of these in Fortran can be found on the internet. I, however, came up with a low-performance algorithm myself, and chose to implement it for fun.

My algorithm goes through the entire grid, and for each site checks if it is occupied and unlabelled. If both these conditions are met, a recursive algorithm grows the entire cluster connected to this site.

The main algorithm is the \lstinline{label} subroutine,
\lstinputlisting[linerange={labelsubroutinestart-labelsubroutineend}]{lib/clusterlabelling.f90}
where the recursive \lstinline{growcluster} subroutine simply checks if each neighbouring site is occupied and unlabelled,
\lstinputlisting[linerange={growclustersubroutinestart-growclustersubroutineend}]{lib/clusterlabelling.f90}
This algorithm is easily extensible to other geometries and connectivities, as the basic idea ``check all sites, check all neighbours'' is generally valid. Higher dimensions should also be unproblematic, although a generalisation of checking all neighbours would be useful to avoid tedious coding.

There is, however, one pressing issue with this algorithm: It is recursive (and not tail-recursive). As a result, it will give a stack overflow when run on sufficiently large systems. For this reason, I reluctantly had to abandon my algorithm and instead write a small Fortran interface for a C implementation of the Hoshen-Kopelman algorithm found on the internet\cite{fricke_hoshen-kopelman_2004}. Unfortunately, this implementation uses a lot of global variables and is not thread safe, so I now have my own Fortran implementation.

Spanning cluster detection is done by checking if either the top and bottom rows or the left and right columns contain common elements. This is implemented by first going through one of the arrays and registering which labels are present, and then going through the other array and checking if any of the labels in this array were also present in the first,
\lstinputlisting[linerange={intersectsnippetstart-intersectsnippetend}]{lib/clusterlabelling.f90}
The algorithm assumes that there is only one spanning cluster. This should be unproblematic, as it is higly unlikely that two clusters stretch from one side of the grid to the other without touching each other and thus being the same cluster. When the label of the spanning cluster has been found, the area is straightforwardly calculated by a command like \lstinline{count(labelled_matrix == spanning_label)}.
A sample run gives
\lstinputlisting{tmp/verification.txt}

The functions \(\Pi(p,L)\) and \(P(p,L)\) are estimated by repeating a simulation multiple times. \(\Pi(p,L)\) is the number of repetitions which lead to a spanning cluster divided by the total number of repetitions, while \(P(p,L)\) is estimated by the average size of the spanning cluster (or zero if there isn't one), divided by the total size of the grid, \(L^2\). Averaging over many cycles is trivially parallelisable with OpenMP.

%  _
% | |__
% | '_ \
% | |_) |
% |_.__/
%
\subsection{}
The probability of having a spanning cluster, \(\Pi(p,L)\), and the density of the spanning cluster, \(P(p,L)\), were estimated with the Fortran machinery described in the previous exercise. \(\Pi(p,L)\) is calculated by creating many random, binary matrices, counting the numbers of matrices which have a spanning cluster and dividing by the total number of matrices created.

If there is no spanning cluster, \(P(p,L)=0\), otherwise it is equal to the number of sites belonging to the spanning cluster, divided by the total number of sites. Hence it is equal to the the probability of one randomly selected site being on the spanning cluster. An estimate is found by creating and labelling many binary matrices and averaging the number of sites on the spanning cluster (or zero), and dividing by the total number of sites on the lattice.

Mathematically,
\begin{alignat}{2}
    \Pi(p,L) &= \frac{\displaystyle\sum_{\text{cycles}} \begin{cases}1, & \text{spanning cluster exists}\\ 0, & \text{no spanning cluster exists}\end{cases}}{\text{number of cycles}}
    \shortintertext{and}
    P(p,L) &= \frac{\displaystyle\sum_{\text{cycles}} \begin{cases}0,&\text{no spanning cluster exists}\\& \text{mass of spanning cluster} \end{cases}}{L^2\cdot\text{number of cycles}}.
\end{alignat}

A variety of system sizes \(L\) and numbers of samples were used for probabilities in the range from zero to one. See~\vref{fig:PI} and~\vref{fig:PL}.
\begin{figure}[bth]
    \centering
    \begin{subfigure}{\textwidth}
        \centering
        \begin{tikzpicture}
            \begin{axis}[
                legend style={draw=none,at={(1.0,0.8)}},
                legend cell align=left,
                thick,
                axis lines=middle,
                xlabel style={anchor=north west},
                ylabel style={anchor=east},
                %axis y discontinuity=crunch,
                enlarge x limits=0.05,
                enlarge y limits=0.1,
                width=6in, height=3in,
                xlabel={\(p\)},
                ylabel={\(\Pi(p,L)\)}
                ]
                    \foreach \systemsize in {2,4,8,16,32,64,128} {
                        \addplot+[mark=none] table {tmp/PI_1000_\systemsize.dat};
                        \addlegendentryexpanded{\(L = \num{\systemsize} \)};
                    }
            \end{axis}
        \end{tikzpicture}
        \caption{Different system sizes. As \(L\) increases, the function shape approaches a step function, with a clearly defined critical probability \(p_\mathrm{c}\). Averaged over \(\num{1000}\) Monte Carlo samples.}%
    \end{subfigure}
    \begin{subfigure}{\textwidth}
        \centering
        \begin{tikzpicture}
            \begin{axis}[
                legend style={draw=none,at={(1.0,0.65)}},
                legend cell align=left,
                thick,
                axis lines=middle,
                xlabel style={anchor=north west},
                ylabel style={anchor=east},
                %axis y discontinuity=crunch,
                enlarge x limits=0.05,
                enlarge y limits=0.1,
                width=6in, height=3in,
                xlabel={\(p\)},
                ylabel={\(\Pi(p,L)\)}
                ]
                    \foreach \systemsize in {2,128} {
                        \foreach \numsamples in {10,100,1000}{
                            \addplot+[mark=none] table {tmp/PI_\numsamples_\systemsize.dat};
                            \addlegendentryexpanded{\(L = \systemsize\), \(\num{\numsamples}\) samples};
                        }
                    }
            \end{axis}
        \end{tikzpicture}
        \caption{Different numbers of Monte Carlo cycles for the largest and smallest system sizes simulated.}%
    \end{subfigure}
    \caption{Probability of having a spanning cluster, compared both for different system sizes and for different numbers of Monte Carlo cycles. The graphs show that large systems give good results with very few samples, while small systems require a large number of samples to give good results with little noise.}
    \label{fig:PI}
\end{figure}
\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            legend style={draw=none,at={(1.0,0.7)}},
            legend cell align=left,
            thick,
            axis lines=middle,
            xlabel style={anchor=north west},
            ylabel style={anchor=east},
            %axis y discontinuity=crunch,
            enlarge x limits=0.05,
            enlarge y limits=0.1,
            width=6in, height=3in,
            xlabel={\(p\)},
            ylabel={\(P(p,L)\)}
            ]
                \foreach \systemsize in {2,4,8,16,32,64,128} {
                    \addplot+[mark=none] table {tmp/P_1000_\systemsize.dat};
                    \addlegendentryexpanded{\(L = \num{\systemsize} \)};
                }
        \end{axis}
    \end{tikzpicture}
    \caption{Spanning cluster density as a function of the probability \(p\) for a site to permit transport, for several system sizes, with \(\num{1000}\) samples. For large systems, the density has a clear jump when it becomes probable to have a spanning cluster. Beyond this value, the density increases linearly as the size of the spanning cluster increases.}%
    \label{fig:PL}
\end{figure}

\subsection{}
The same functions as in the previous exercise were used to calculate \(P(p,L)\) for probabilities going from slightly above the critical probability, \(p_c\), to \(\SI{20}{\percent}\) above \(p_c\). A lower bound of exactly \(p_c\) makes the computer complain when attempting to calculate \(\ln(p-p_c)\).

According to the exercise description, the spanning cluster density \(P(p,L)\) should be proportional to \(\qty(p-p_c)^\beta\) for some exponent \(\beta\) for \(p>p_c\). The exponent is found by doing linear regression on a log-log scale, as
\[
    P(p,L) = a\qty(p-p_c)^\beta \implies \log_{10}(P(p,L)) = \log_{10}(a) + \beta\log_{10}(p-p_c).
\]
\openin\infile=tmp/c_beta.dat
\read\infile to \mybeta
\closein\infile
The exponent is therefore the slope of \(\log_{10}(P(p,L))\) as a function of \(\log_{10}(p-p_c)\). \Vref{fig:cP} shows the simulation results together with the theoretical model with \(\beta=\num{\mybeta}\) found from linear regression.

Fortran does, unfortunately, not have an \lstinline{np.polyfit} function, so the linear fit was done manually by calling a least squares subroutine from LAPACK.\@ \Vref{fig:cP} shows the result.

A fairly poor fit is found for probabilities which are either close to or far away from the critical probability. The error for probabilities close to the critical probability is due to finite size effects; the theoretical model is exactly zero, while the finite size of the lattice causes the spanning cluster density to become non-zero even when \(p\) is slightly smaller than \(p_c\). On the opposite side of the spectrum, the deviation is also large when \(p\gg p_c\) due to the limited range of validity for the theoretical model.

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            legend style={draw=none,at={(1.0,0.7)}},
            legend cell align=left,
            thick,
            %axis lines=middle,
            xlabel style={anchor=west},
            ylabel style={anchor=south east},
            %axis y discontinuity=crunch,
            enlarge x limits=0.05,
            enlarge y limits=0.1,
            width=6in, height=3in,
            xlabel={\(p\)},
            ylabel={\(P(p,L)\)},
            xtick distance=0.01
            ]
            \addplot+[mark=none] table[x index=0, ,y index=1] {tmp/c_P.dat};
            \addlegendentryexpanded{Simulation results};
            \addplot+[mark=none] table[x index=0, ,y index=2] {tmp/c_P.dat};
            \addlegendentryexpanded{\(c\qty(p-p_c)^{\num{\mybeta}}\)};
        \end{axis}
    \end{tikzpicture}
    \caption{Spanning cluster density as a function of the probability \(p\) with \(L=\num{512}\) and \(\num{100}\) cycles for probabilities in the region just above the critical probability. The result is compared with \(c\qty(p-p_c)^\beta\), where \(\beta\) is found by doing a linear fit on a logarithmic scale. }%
    \label{fig:cP}
\end{figure}


%      _
%   __| |
%  / _` |
% | (_| |
%  \__,_|
%
\subsection{}
The cumulative distribution and the derivative, which approximates the probability distribution, were straightforwardly calculated using
\lstinputlisting[language=Python,rangeprefix=\#\ /,rangesuffix=/\ \#, linerange={Pstart-Pend}]{src/d.py}
and the results are shown in~\vref{fig:d}.
\openin\infile=tmp/d_a.dat
\read\infile to\myslope
\closein\infile
\begin{figure}[htb]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \begin{tikzpicture}
            \begin{axis}[
                legend style={draw=none,at={(1.0,0.7)}},
                legend cell align=left,
                thick,
                axis lines=middle,
                %xlabel style={anchor=north},
                %ylabel style={anchor=south east},
                %axis y discontinuity=crunch,
                xmin=0,
                enlarge x limits=0.05,
                enlarge y limits=0.1,
                width=3.4in, height=3in,
                xlabel={\(z\)},
                ylabel={\(P(z)\)},
                ]
                \addplot+[mark=none] table {tmp/d_P.dat};
            \end{axis}
        \end{tikzpicture}
        \caption{Cumulative distribution.}%
    \end{subfigure}\quad
    \begin{subfigure}[b]{0.45\textwidth}
        \begin{tikzpicture}
            \begin{axis}[
                legend style={draw=none,at={(1.1,0.8)},anchor=east},
                legend cell align=left,
                thick,
                axis lines=middle,
                %xlabel style={anchor=north},
                ylabel style={anchor=east},
                %axis y discontinuity=crunch,
                xmin=0,
                ymax=10,
                restrict x to domain=0:200,
                restrict y to domain=0:200,
                enlarge x limits=0.05,
                enlarge y limits=0.1,
                width=3.4in, height=3in,
                xlabel={\(z\)},
                ylabel={\(f(z)\)},
                ]
                \addplot+[mark=none] table {tmp/d_f.dat};
                \addlegendentryexpanded{Simulation result.};
                \addplot+[mark=none] table {tmp/d_fapprox.dat};
                \addlegendentryexpanded{Approximation \(z^{\num{\myslope}}\)};
            \end{axis}
        \end{tikzpicture}
        \caption{Probability distribution.}%
    \end{subfigure}
    \caption{The result of raising a uniform distribution between \(0\) and \(1\) to the power \(-2\). While the cumulative distribution looks reasonable, it is clear that some sort of averaging over bins is necessary in order to get a reasonable probability distribution.}%
    \label{fig:d}
\end{figure}



%   ___
%  / _ \
% |  __/
%  \___|
%
\subsection{}
The listed algorithm can be used to calculate the cluster number density \(n(s,p)\) with logarithmically binned sizes. \(n(s,p)\) is defined as the probability for a randomly selected site to be a specific site on a cluster with size \(s\). It can therefore be calculated as
\begin{equation}
    n(s,p) = \frac{\displaystyle\sum_{\text{cycles}}\text{number of clusters with size } s}{\text{number of cycles}}.
\end{equation}
Due to the skewed distribution of cluster sizes, with many being small and few large clusters (except for the spanning cluster, which is ignored), this method would give similarly poor results as in~\vref{fig:d}. Consequently, the sizes should be binned logarithmically and the results averaged, i.e.
\begin{equation}
    n\left(\left[s,s+\Delta s\right),p\right) = \displaystyle\sum_{\text{cycles}}\frac{\text{number of clusters with size between } s \text{ and } s+\Delta s}{L^2 \cdot \Delta s \cdot \text{number of cycles}}.
\end{equation}
\lstinputlisting[language=Fortran,linerange={cndstart-cndend}]{lib/clusterlabelling.f90}


%   __
%  / _|
% | |_
% |  _|
% |_|
%
\subsection{}
The cluster number density algorithm from the previous exercise was used. \Vref{fig:f} shows the result for various values of \(p\) for a fixed system size.
\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            xmode=log, ymode=log,
            ymin=0.000000000001,
            legend style={draw=none,at={(0.02,0.02)},anchor=south west},
            legend cell align=left,
            legend columns=2,
            thick,
            %axis lines=middle,
            xlabel style={anchor=west},
            ylabel style={anchor=south east},
            %axis y discontinuity=crunch,
            enlarge x limits=0.05,
            enlarge y limits=0.1,
            width=6in, height=3in,
            xlabel={\(s\)},
            ylabel={\(n(s,p)\)},
            ]
            \begin{luacode*}
                local i = 0
                for line in io.lines("tmp/f_p.dat") do
                    i = i + 1
                    print(line)
                    txt = "\\addplot+[mark=none] table {tmp/f_p_" .. tostring(i) .. ".dat}; \\addlegendentryexpanded{\\(p = \\num{" .. line .. "}\\)};"
                    tex.sprint(txt)
                end
            \end{luacode*}
        \end{axis}
    \end{tikzpicture}
    \caption{Cluster number density as a function of size for a few different probabilities, with \(L=512\) and \(\num{1000}\) Monte Carlo cycles. As \(p\) approaches \(p_c\) from below, a larger and larger portion of the graph is approximately linear. Since both axes are logarithmic, this implies a power-law behaviour, \(n(s,p)\propto s^{-\tau}\).}%
    \label{fig:f}
\end{figure}


%   __ _
%  / _` |
% | (_| |
%  \__, |
%  |___/
\openin\infile=tmp/g_9_tau.dat
\read\infile to \mytau
\closein\infile
\subsection{}
As seen in~\vref{fig:f}, the cluster number density has a large linear part when \(p\to p_c\). Both axes in this figure are logarithmic, so the linearity implies a power-law behaviour for \(n(s,p_c)\), i.e. \(n(s,p_c)\propto s^{-\tau}\). \Vref{fig:g} shows \(n(s,p_c)\) with \(L^i\), \(i\in\qty{4,\dots,9}\), as well as the result of a linear fit for the largest system size. The linear part is found by staring at the graph, and the resulting exponent is \(\tau=\num{\mytau}\).
\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            xmode=log, ymode=log,
            ymin=0.00000000001,
            legend style={draw=none,at={(0.02,0.02)},anchor=south west},
            legend cell align=left,
            legend columns=3,
            thick,
            %axis lines=middle,
            xlabel style={anchor=west},
            ylabel style={anchor=south east},
            %axis y discontinuity=crunch,
            enlarge x limits=0.05,
            enlarge y limits=0.1,
            width=6in, height=3in,
            xlabel={\(s\)},
            ylabel={\(n(s,p_c)\)},
            ]
            \addplot+[mark=none,dashed] table {tmp/g_9_approx.dat};
            \addlegendentryexpanded {\(s^{-\num{\mytau}}\)};
            \foreach \exponent in {9,8,...,4}{
                \addplot+[mark=none] table {tmp/g_\exponent.dat};
                \addlegendentryexpanded {\(L = 2^\exponent\)};
            }
        \end{axis}
    \end{tikzpicture}
    \caption{Cluster number density as a function of size with \(p=p_c\), \(L=512\) and \(\num{1000}\) Monte Carlo cycles. The power-law model fits well over a large range of sizes.}%
    \label{fig:g}
\end{figure}

%  _
% | |__
% | '_ \
% | | | |
% |_| |_|
\openin\infile=tmp/h_sigma.dat
\read\infile to \mysigma
\closein\infile
\subsection{}
Comparing~\vref{fig:f} with~\vref{fig:g} shows that when \(p\approx p_c\), \(n(s,p)\) has a linear portion similar to that of \(n(s,p_c)\), but it falls of from the linear trend when \(s\) becomes large. This point of departure can be defined as a characteristic size \(s_\xi\). It can be numerically estimated as the point where \(n(s,p)\leq \tfrac{1}{2}n(s,p_c)\).

The characterstic size \(s_\xi\) can be assumed\cite{malthe-sorenssen_percolation_2015} to be proportional to \(\abs{p-p_c}^{-1/\sigma}\), where \(\sigma\) once again is found by doing linear regression on a logarithmic scale.~\Vref{fig:h} shows the cluster number density as a function of size for probabilities approaching \(p_c\), with \(s_\xi\) marks based on the numerical estimate described above. The resulting \(s_\xi(p)\) is shown in~\vref{fig:h2}, and the theoretical model \(\abs{p-p_c}^{-1/\num{\mysigma}}\) gives a good approximation of the simulation results.

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            xmode=log, ymode=log,
            ymin=0.000000000001,
            legend style={draw=none,at={(0.02,0.02)},anchor=south west},
            legend cell align=left,
            legend columns=2,
            thick,
            %axis lines=middle,
            xlabel style={anchor=west},
            ylabel style={anchor=south east},
            %axis y discontinuity=crunch,
            enlarge x limits=0.05,
            enlarge y limits=0.1,
            width=6in, height=3in,
            xlabel={\(s\)},
            ylabel={\(n(s,p)\)},
            ]
            \addplot+[only marks] table {tmp/h_s_xi.dat};
            \addlegendentryexpanded{\(s_\xi\)};
            \begin{luacode*}
                local i = 0
                for line in io.lines("tmp/h_p.dat") do
                    i = i + 1
                    print(line)
                    txt = "\\addplot+[mark=none] table {tmp/h_"
                          .. tostring(i) .. ".dat};"
                          .. "\\addlegendentryexpanded{\\(p = \\num{"
                          .. line .. "}\\)};"
                    tex.sprint(txt)
                end
            \end{luacode*}
        \end{axis}
    \end{tikzpicture}
    \caption{Cluster number density as a function of size for probabilities just above \(p_c\) with \(L=512\) and \(\num{2000}\) Monte Carlo cycles. The dots mark the numerical estimates of \(s_\xi\).}%
    \label{fig:h}
\end{figure}

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            legend style={draw=none,at={(1.0,0.7)}},
            legend cell align=left,
            thick,
            xmin=0.4, xmax=0.7,
            %axis lines=middle,
            %xlabel style={anchor=north},
            %ylabel style={anchor=south east},
            %axis y discontinuity=crunch,
            enlarge x limits=0.05,
            enlarge y limits=0.1,
            width=6in, height=3in,
            xlabel={\(p\)},
            ylabel={\(s_\xi\)},
            xtick distance=0.05,
            ]
            \addplot+[only marks] table[x index=0, ,y index=1] {tmp/h_s_xi2.dat};
            \addlegendentryexpanded{Simulation results};
            \addplot+[mark=none] table[x index=0, ,y index=2] {tmp/h_s_xi2.dat};
            \addlegendentryexpanded{\(\abs{p-p_c}^{-1/\num{\mysigma}}\)};
        \end{axis}
    \end{tikzpicture}
    \caption{Characteristic cluster size \(s_\xi\) as a function of probability. As the probability approaches the critical probability, \(s_\xi\) diverges. The parameters of the power law model are found from linear regression on a logarithmic scale, and the resulting approximation looks good.}%
    \label{fig:h2}
\end{figure}

%  _
% (_)
% | |
% | |
% |_|
%
\openin\infile=tmp/i_D.dat
\read\infile to \myD
\closein\infile
\subsection{}
The mass of the percolating/spanning cluster \(M\) should be proportional to some power of the system size \(L\). Intuitively, the exponent should be equal to the dimension of the system (\(2\) in this project), but the non-trivial geometry of the spanning cluster causes the exponent to deviate from this expectation. This is confirmed by the numerically determined \(D=\num{\myD}<2\). \Vref{fig:i} shows the quality of the approximation.

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            xmode=log, ymode=log,
            log basis x=2,
            legend style={draw=none,at={(0.02,0.98)},anchor=north west},
            legend cell align=left,
            %legend columns=3,
            thick,
            %axis lines=middle,
            %xlabel style={anchor=west},
            %ylabel style={anchor=south east},
            %axis y discontinuity=crunch,
            enlarge x limits=0.05,
            enlarge y limits=0.1,
            width=6in, height=3in,
            xlabel={\(L\)},
            ylabel={\(M\)},
            ]
            \addplot+[only marks] table[x index=0, y index=1] {tmp/i.dat};
            \addlegendentryexpanded {Simulation results};
            \addplot+[mark=none] table[x index=0, y index=2] {tmp/i.dat};
            \addlegendentryexpanded {Approximation \(L^{\num{\myD}}\)};
        \end{axis}
    \end{tikzpicture}
    \caption{Mass of the percolating cluster as a function of system size, with \(p=p_c\) and \(200\) Monte Carlo cycles. The power-law model fits well, and \(D=\num{\myD}<2\) shows the non-trivial geometry of the percolating cluster.}%
    \label{fig:i}
\end{figure}

\subsection{}
Nope.
\subsection{}
Nope.

%  _
% | |
% | |
% | |
% |_|
%
\subsection{}

















\nocite{*}
\printbibliography{}
\addcontentsline{toc}{chapter}{\bibname}
\end{document}
